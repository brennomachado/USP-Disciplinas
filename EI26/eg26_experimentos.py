# -*- coding: utf-8 -*-
"""EG26: experimentos

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e-vdQ6yBLRLe_25p1R-EAkMqOdBE36LD
"""

'''
    MAC0122 Princípios de Desenvolvimento de Algoritmos

    PROBLEMA LCS: dadas duas strings s e t, encontrar uma maior 
        subsequência comum de s e t.

    TÓPICO: análise dos algoritmos

    - lcs_rec()
    - lcs_iterPD()


    DATA DA ÚLTIMA ATUALIZAÇÃO: 29/11/2021
'''
#------------------------------------------------------------
# carrega as coisas do Python
import sys
MAX_PILHA_RECURSAO = 2**16
sys.setrecursionlimit(MAX_PILHA_RECURSAO)  
# https://docs.python.org/3/library/time.html
# timer para cronometraros tempos de execução
from timeit import default_timer as Timer
# https://docs.python.org/3/library/random.html
import random
# https://docs.python.org/3/library/string.html
import string

#-----------------------------------------------------------
# CARREGA: subseq(), lcs_rec(), lcs_iterPD()
from eg_lcs import *

#-----------------------------------------------------------
# GERA gráficos usando pyplot
# Para saber mais sobre pyplot: 
# https://matplotlib.org/stable/tutorials/introductory/pyplot.html#logarithmic-and-other-nonlinear-axes
import numpy as np
import matplotlib.pyplot as plt
# coordenadas
X = 0
Y = 1
# outras constantes
ESCALA_LOG = False # True

SEMENTEs = 1 # para reprodutibilidade
SEMENTEt = 2 # para reprodutibilidade

# para geração das strings aleatórias
# ALFABETO = string.ascii_uppercase
ALFABETO = "ACGT"

#-----------------------------------------------------------
# ESCOLHA 1: escolha apenas 1 método
# FUNCAO = lcs_rec
FUNCAO = lcs_iterPD

#-----------------------------------------------------------
# ESCOLHA 2: escolha, COM MODERAÇÃO, o número de pontos
#    no gráfico (= número de tamanhos de listas)
NO_PONTOS = 12

#---------------------------------------------------------
# Não precisa mexer em mais nada
# comprimento as strings
POT_MIN = 4
POT_MAX = POT_MIN+NO_PONTOS-1
MIN = 2**POT_MIN
MAX = 2**POT_MAX

#--------------------------------------------------------
STR_FUNCAO = f"{FUNCAO}".split()[1] # Que horror!
CABECALHO  = f"         n {STR_FUNCAO:>14}     len(lcs)"

def main():
    print(f"{STR_FUNCAO}: testes com strings aleatorias de mesmo comprimento")

    #---------------------------------------------------
    # gere s
    random.seed(SEMENTEs) # para reprodutibilidade
    s = "".join(random.choices(ALFABETO, k=MAX))
    # print(f"s: {s}")
    #---------------------------------------------------
    # gere t
    random.seed(SEMENTEt) # para reprodutibilidade
    t = "".join(random.choices(ALFABETO, k=MAX))
    # print(f"t: {t}")
    
    print(CABECALHO)
    pontos = np.zeros((2,NO_PONTOS))
    k = 0
    i = MIN
    while i <= MAX:
        #----------------------------------------
        # lcs versão {FUNCAO}
        t_lcs, len_lcs = cronometre(FUNCAO, s[0:i], t[0:i]) 

        #--------------------------------------
        # registre o ponto
        pontos[X,k], pontos[Y,k] = i, t_lcs
        k += 1
        
        # exiba resultados
        print(f"{i:10} {t_lcs:12.2f} {len_lcs:12}")
        
        # dobre o tamanho da entrada
        i *= 2

    print("tempos em segundos\n")    
    print("Para encerra feche a janela...")
    if ESCALA_LOG: plt.yscale('log')
    plt.grid(True)
    plt.title(f'{STR_FUNCAO}')
    plt.plot( pontos[X], pontos[Y], 'b') # blue 
    plt.plot( pontos[X], pontos[Y], 'b+') # blue +  
    plt.show()
    print("FUI!")

#-------------------------------------------              
def cronometre(f, s, t):
    '''(callable, str, str) -> float
    RECEBE uma função f e duas strings s e t.
    RETORNA o tempo gasto e o comprimento da string retornada pela 
        execução de f(s, t).
    '''
    # cronometre o tempo
    t_ini = Timer()
    lcs = f(s, t)
    t_fim = Timer()
    elapsed = t_fim-t_ini

    # usa a função subse() para verificar se lcs é substring de s e de t
    # não garante que é a maior
    if not subseq(lcs, s) or not subseq(lcs, t):
        print("SOCORRO! A string encontrada não é substring de s e t")
    
    return elapsed, len(lcs)

#---------------------------------------------------
if __name__ == '__main__':
    main()