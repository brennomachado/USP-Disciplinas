# -*- coding: utf-8 -*-
"""eg19 expermento algoritmos de busca.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15VZLqDj_grvjUmE2IW4vDtJ3I9_V78WI
"""

'''
    MAC0122 - Princípios de Desenvolvimento de Algoritmos

    Experimento
    Análise de algoritmos de busca em lista ordenada.
    Todos os algoritmos são comparados com a busca_sequencial 
    em lista NAO ordenada, mostrada na linha verde.
    
    Tópico: análise dos algoritmos

    - busca_sequencial
    - busca_sequencial_em_lista_ordenada
    - busca_binariaR (interface para a função busca_binaria_RED)
    - busca_binariaI

    Data da última atualização: 3/11/2021

'''
################################################################
# carrega as coisas do Python

# sys para controlar o tamanho da pilha de recursão
import sys
import random
# timer para medir tempos de execução
from timeit import default_timer as Timer
# 
# para ver gráficos vamos usar pyplot
# Para saber mais sobre pyplot: 
# https://matplotlib.org/stable/tutorials/introductory/pyplot.html#logarithmic-and-other-nonlinear-axes
import numpy as np
import matplotlib.pyplot as plt

################################################################
# carrega todas suas funções, iterativas e recursivas
from eg_busca import *

################################################################
################################################################
# configuração da pilha e constantes do experimento.
# Essas constantes podem ser alteradas para adaptá-las a sua máquina

MAX_PILHA_RECURSAO = 1000000
sys.setrecursionlimit(MAX_PILHA_RECURSAO)  


## Avaliação em pares
## insira/remova/edite os pares de funções na lista para serem avaliadas
PARES_DE_FUNCOES = [
    [ busca_sequencial, busca_sequencial_em_lista_ordenada ],
#     [ busca_sequencial_em_lista_ordenada, busca_binariaR ],
#     [ busca_binariaR, busca_binariaI ],
    ]

## listas de tamanho N
VALOR_N_INICIAL = 1000
NUMERO_DE_ITERACOES = 12  # cada iteração dobra o valor de N
BUSCAS_POR_ITERACAO = 100 # para analisar o tempo médio

# FATOR_BUSCA_FORA deve ser um inteiro > 0. 
# Quando 1, 1/1 ou todas as buscas são feitas com elementos no vetor. 
# Quando 2, 1/2 das buscas são feitas com elementos no veto
# Quando 3, 1/3 das buscas, etc.
FATOR_BUSCAS_FORA = 2 

## outras constantes
ESCALA_LOG = True
FUNCAO_VERDE = busca_sequencial

################################################################
#
# não deve ser necessário alterar mais nada daqui para baixo...
#
################################################################
'''
main()
    essa função roda o experimento que compara os
    tempos de execução de pares de funções.
'''
def main():

    ## lista com os pares de funções a serem comparadas

    for par in PARES_DE_FUNCOES:
        
        graf0 = np.zeros((2,NUMERO_DE_ITERACOES))
        graf1 = np.zeros((2,NUMERO_DE_ITERACOES))
        graf2 = np.zeros((2,NUMERO_DE_ITERACOES))

        nome0 = str(FUNCAO_VERDE).split()[1]
        nome1 = str(par[0]).split()[1]
        nome2 = str(par[1]).split()[1]

        print('\n<<<   =======  ALGORITMOS DE BUSCA =======   >>>\n')
        print(f"   alg_0 = {nome0} em lista não ordenada (curva verde)" )
        print(f"   alg_1 = {nome1} em lista ordenada" )
        print(f"   alg_2 = {nome2} em lista ordenada\n")
        print( '   n   \t | tempo alg_0 \t | tempo alg_1 \t | tempo alg_2 \t | razão dos tempos alg_2 / alg_1 | ')

        n = VALOR_N_INICIAL
        for i in range( NUMERO_DE_ITERACOES ):
            graf2[0,i] = graf1[0,i] = graf0[0,i] = n

            max_val = n * FATOR_BUSCAS_FORA        

            res0 = experimento_busca_seq( busca_sequencial, BUSCAS_POR_ITERACAO, n, max_val)
            res1 = experimento_busca_seq_ordenada(par[0], BUSCAS_POR_ITERACAO, n, max_val)
            res2 = experimento_busca_seq_ordenada(par[1], BUSCAS_POR_ITERACAO, n, max_val)

            print( f"{n:6}\t|", end=' ')
            print( f"({res0:.6f}s\t |", end=' ')
            print( f"({res1:.6f}s\t |", end=' ')
            print( f"({res2:.6f}s\t |", end=' ')
            razao = res2 / res1
            print( f"{razao:10.2f}")

            graf0[1,i] = res0
            graf1[1,i] = res1
            graf2[1,i] = res2
            n = 2 * n

        print("Feche a janela do gráfico para continuar e avaliar o próximo par de funções ...")
     
        if ESCALA_LOG:
            plt.yscale('log')
        plt.grid(True)
        plt.title(f'{nome1} (azul) x {nome2} (vermelho)')
        plt.plot( graf0[0], graf0[1], 'g') # green
        plt.plot( graf1[0], graf1[1], 'b') # blue 
        plt.plot( graf2[0], graf2[1], 'r') # red  
        plt.plot( graf0[0], graf0[1], 'go') # green o  
        plt.plot( graf1[0], graf1[1], 'b+') # blue +  
        plt.plot( graf2[0], graf2[1], 'r*') # red  *
        plt.show()

# ................................................

def experimento_busca_seq_ordenada(funcao, n_sorteios, n, max_val):
    ''' ( func, int, int, int ) -> list
    Recebe o nome de uma função de busca em sequencia ordenada.
    Cria uma lista ordenada como n elementos.
    Sorteia n_sorteios valores no intervalo [0:max_val].
    Mede o tempo para a função buscar o valor sorteado. 
    Retorna o tempo médio.
    '''

    seq = list(range(n))

    t_dif = 0
    for i in range(n_sorteios):
        item = random.randrange(max_val)
        t_ini = Timer()
        ind = funcao( seq, item )
        t_fim = Timer()
        t_dif += t_fim - t_ini
        
    return t_dif / n_sorteios 

# ................................................

def experimento_busca_seq(funcao, n_sorteios, n, max_val):
    ''' ( func, int, list, int ) -> list
    Recebe o nome de uma função de busca.
    Sorteia n_sorteios valores no intervalo [0:max_val].
    Mede o tempo para a função buscar o valor sorteado. 
    Retorna o tempo médio.
    '''

    seq = list(range(n))
    random.shuffle(seq)

    t_dif = 0
    for i in range(n_sorteios):
        item = random.randrange(max_val)
        t_ini = Timer()
        ind = funcao( seq, item )
        t_fim = Timer()
        t_dif += t_fim - t_ini
        
    return t_dif / n_sorteios 

# ................................................
if __name__ == '__main__':
    main()