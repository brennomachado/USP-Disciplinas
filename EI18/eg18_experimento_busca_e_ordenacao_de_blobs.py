# -*- coding: utf-8 -*-
"""eg18 experimento: busca e ordenacao de blobs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t8bnh2Nq_yM8BiDJ10sy5IZxL42WyzsF
"""

'''
    MAC0122 - Princípios de Desenvolvimento de Algoritmos

    Tópico: desenvolvimento de algoritmos

    - max_blob
    - ordene_por_selecao
    - busque_blob

    Data da última atualização: 27/10/2021
'''

################################################################
# COISAS DO EXPERIMENTO
################################################################
# configuração da pilha e constantes do experimento.
# Essas constantes podem ser alteradas para adaptá-las a sua máquina

# Modifique 
# EXP_ORDENACAO para False para rodar o outro experimento
EXP_ORDENACAO = True

## insira / remova arquivos de imagens 
ARQUIVOS = ['binary.png', 'mondrian_p.png', 'mondrian.png', 'tom.png', 'fred.jpg']

# valores usando no experimento de busque_blob
MENOR_BLOB = 1
MAIOR_BLOB = 20

################################################################
# carrega as coisas do Python
################################################################

# sys para controlar o tamanho da pilha de recursão
import sys
MAX_PILHA_RECURSAO = 1000000
sys.setrecursionlimit(MAX_PILHA_RECURSAO)  

# timer para medir tempos de execução
from timeit import default_timer as Timer

import numpy as np
from PIL import Image

################################################################
# carrega suas coisas
from eg_blobs import Blobs

# ###################################################################
# COISAS DAS IMAGENS
# ###################################################################
# níveis de cinza: 
# poucos níveis de cinza ajuda a formar blobs maiores
NIVEIS_DE_CINZA = 16

# constrói um mapa de cores para realçar os resultados
# mapeia um inteiro para uma cor RGB
# você pode incluir outras cores se desejar.
RED, GREEN, BLUE = -1, -2, -3
YELLOW, MAGENTA, CYAN = -4, -5, -6
MAPA = {
    RED:(255, 0, 0),
    GREEN:(0,255,0),
    BLUE:(0,0,255),
    YELLOW:(255,255,0),
    MAGENTA:(255,0,255),
    CYAN:(0,255,255)
}

# ###################################################################
#
# não deve ser necessário alterar mais nada daqui para baixo...
#

def main():
    ''' 
    apenas chama um ou outro experimento
    '''

    if EXP_ORDENACAO:
        exp_ordenacao()
    else:
        exp_busca(MENOR_BLOB, MAIOR_BLOB)

# ###################################################################

def exp_ordenacao( cor = YELLOW):
    ''' (None) -> None
    para cada imagem na lista ARQUIVOS,
    permite ver cada blob, da maior até a menor.
    '''

    for fname in ARQUIVOS:
        print(f'Processando o arquivo {fname}')

        # carrega imagem colorida
        image = Image.open(fname)
        # ginástica para conversar para 1 canal de cinza
        gray = image.convert("L")
        gray.show()
        input("Tecle ENTER para continuar ...")

        img = np.asarray(gray).copy().astype(int)
        reduza_cores(img, NIVEIS_DE_CINZA)

        # segmenta blobs
        blobs = Blobs(img)
        n = len(blobs.data)
        print(f'Achei {n} blobs')
        print('Ordenando ... ')
        comeco = Timer()
        blobs.ordena_por_selecao()
        termino = Timer()
        print(f"Consumo de tempo para ordenar: {termino-comeco} s")

        fim = n - 1

        while fim >= 0:
            blob = blobs.data[ fim ]  # maior blob
            print(f'Blob de indice {fim} tem tamanho {len(blob)}')
            blobs.pinte_blob(img, blob, cor )
            rgb = map_and_show( img , MAPA)
        
            rgb.show()
            opcao = input("Tecle ENTER para continuar,\n  i + ENTER para próxima imagem ou\n  q + ENTER para sair: ")

            if opcao == 'i' or opcao == 'q': fim = 0
            fim -= 1
        if opcao == 'q': break


#################################################################

def exp_busca(ini, fim):
    ''' (int, int) -> None
    marca os blobs de tamanho ini até fim.
    '''

    for fname in ARQUIVOS:
        print(f'Processando o arquivo {fname}')
        print(f"mostrando apenas os blobs de tamanho {ini} até {fim}")

        # carrega imagem colorida
        image = Image.open(fname)
        # ginástica para conversar para 1 canal de cinza
        gray = image.convert("L")
        img = np.asarray(gray).copy().astype(int)
        reduza_cores(img, NIVEIS_DE_CINZA)

        # segmenta blobs
        blobs = Blobs(img)
        n = len(blobs.data)
        print(f'Achei {n} blobs')
        print(f'Fazendo busca em lista não ordenada.\n')

        pintar = set()
        total = 0
        tempo_total = 0.0
        buscas = 0
        for size in range(ini, fim):
            conta = 0

            buscas += 1
            comeco = Timer()
            b = blobs.busque_blob(size, 0)
            termino = Timer()
            tempo_total += termino-comeco

            while b is not None:
                
                pintar |= blobs.data[b]
                conta += 1
                buscas += 1

                comeco = Timer()
                b = blobs.busque_blob(size, b+1)
                termino = Timer()
                tempo_total += termino-comeco

            if conta > 0:
                print(f"Achei {conta} blobs de tamanho {size}")
                total += conta

        print()
        print(f"Pintei {total} blobs dos {n}")
        print(f"Fiz {buscas} buscas com consumo total: {tempo_total}")
        print()

        blobs.pinte_blob(img, pintar, CYAN )
        rgb = map_and_show( img , MAPA)
        
        rgb.show()
        opcao = input("Tecle ENTER para continuar: ")

#################################################################

def map_and_show(img, map={255:(255,0,0), 0:(0,255,0)}):
    ''' (img, dict) -> None
    '''
    R = img.copy()
    G = img.copy()
    B = img.copy()
    
    for val in map:
        R[ img[:,:] == val ] = map[val][0]
        G[ img[:,:] == val ] = map[val][1]
        B[ img[:,:] == val ] = map[val][2]
    
    r = Image.fromarray(R.astype(np.uint8))
    g = Image.fromarray(G.astype(np.uint8))
    b = Image.fromarray(B.astype(np.uint8))

    im = Image.merge('RGB', (r, g, b))
    return im

# ###################################################################

def reduza_cores(img, n=2):
    '''
    imagens reais tem muitos tons de cinza, como 256.
    uma imagem binário tem apenas 2.
    uma imagem com menos níveis deve apresenta blobs maiores.
    '''

    niveis = 256//n
    mapa = {}
    cor = 0
    for i in range(256):
        mapa[i] = cor
        if i%niveis == 0:
            cor += niveis

    nlin, ncol = img.shape
    for lin in range(nlin):
        for col in range(ncol):
            img[lin,col] = mapa[ img[lin,col] ]

#################################################################

main()